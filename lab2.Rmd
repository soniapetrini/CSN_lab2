---
title: "CSN_lab2"
output: html_notebook
---

# Analysis of nodes degree distribution 

After finding the parameters and the best model, plot the data and a theoretical curve to see if there is sufficient agreement 

("I give x and y, use a double log scale for viz")

```{r}
library(ggplot2)
library(xtable)
require("stats4") # for MLE
require("VGAM")
```


Degree sequence of the English network

```{r}


#nrow(degree_sequence)   # number of nodes 
#sum(degree_sequence)    # sum of total degrees
#sum(degree_sequence)/dim(degree_sequence)[1]    # mean degree
#spectrum <- table(degree_sequence)
```

```{r}
#barplot(spectrum, main = "English",
#        xlab = "degree", ylab = "number of vertices")
```

```{r}
#barplot(spectrum, main = "English",
#        xlab = "degree", ylab = "number of vertices", log = "xy")
```


# IN-DEGREE DISTRIBUTION

### Collect the node degree of every language

```{r}
source = read.table("list_in.txt", header = TRUE, 
         as.is = c("language","file"))

degree_distrib_ls = c()

for (x in 1:nrow(source)) {
    degree_distrib_ls[x] = read.table(source$file[x])
}


```


### Summary Table

```{r}
summary_tab <- data.frame()
i = 1
for (l in 1:length(degree_distrib_ls)) {
  summary_tab[i,1] <- source$language[i]
  summary_tab[i,2] <- length(unlist(degree_distrib_ls[[l]]))
  summary_tab[i,3] <- max(unlist(degree_distrib_ls[[l]]))
  summary_tab[i,4] <- sum(unlist(degree_distrib_ls[[l]]))/length(unlist(degree_distrib_ls[[l]]))
  summary_tab[i,5] <- length(unlist(degree_distrib_ls[[l]]))/sum(unlist(degree_distrib_ls[[l]]))
  i = i + 1
}

colnames(summary_tab) <- c("lang","N","max k","M/N","N/M")
print(xtable(summary_tab))
```






## Fitting Distributions

### Find starting parameter
# For gammma_1 and gamma_2, we can fit a lin reg of log(f(k)) over log(k), we measure probability thorugh sequence 


### Opt parameters with MLE

```{r}

get_mle_params <- function(x) {
    # global variables
    M <- sum(x)
    N <- length(x)
    M_1 <- sum(log(x))
    H <- function(kmax,gamma) {
      s <- 0
      for (i in 1:kmax) {
        s <- s + (1/(i^gamma))
        }
      return(s)
      }
    
    ## Poisson
    minus_log_like_poisson <- function(lambda) {
      C <- 0;
      for(i in 1:N) {
        for(j in 2:x[i]) {
          C<-C+log(j)
        }
      }
      return(- M * log(lambda) + N*(lambda + log(1-(exp(-lambda)))) + C)
    }
    
    
    ## Geometric
    minus_log_like_geom <- function(q) {
      - (M-N)*log(1-q) - N*log(q)
    }
    
    ## zeta
    minus_log_like_zeta <- function(gamma) {
      N * log(zeta(gamma)) + gamma * M_1
    }
    
    ## Trunc Zeta
    minus_log_like_trunc_zeta <- function(kmax,gamma) {
      gamma*M_1 + N*log(H(kmax,gamma))
    }

    # ml estimation
    
    mle_geom <- mle(minus_log_like_geom,start = list(q = N/M),method = "L-BFGS-B",
                    lower = c(0.00001),upper = c(0.99999))
    
    mle_zeta <- mle(minus_log_like_zeta,start = list(gamma = 2),method = "L-BFGS-B",
                    lower = c(1.0000001))
    
    mle_poisson <- mle(minus_log_like_poisson,start = list(lambda = M/N),method = "L-BFGS-B",
                       lower = c(0.0000001))
    
    mle_trunc_zeta <- mle(minus_log_like_trunc_zeta,start = list(gamma = 3, kmax=max(x)),method = "L-BFGS-B",
                       lower = list(kmax = 1), upper = list(kmax = N))
    
    
    mle_ls <- c(mle_poisson,mle_geom,mle_zeta,mle_trunc_zeta)
    
    
    
    # collect the best par for each distribution
    best_pars <- c()
    i <- 1
    for (n in 1:length(mle_ls)) {
      if (n < length(mle_ls)) {
          best_pars[i] <- attributes(summary(mle_ls[[n]]))$coef[1]
          i <- i + 1
          }
      else {
        best_pars[i] <- attributes(summary(mle_ls[[n]]))$coef[2]
        best_pars[i+1] <- attributes(summary(mle_ls[[n]]))$coef[1]
      }
      
    }
    
    
    # collect -2logLike 
    m2loglik_ls <- c()
    i <- 1
    for (n in mle_ls) {
      m2loglik_ls[i] <- m2logL <- attributes(summary(n))$m2logL
      i <- i + 1
    }

    
    return(list(best_pars,m2loglik_ls))
    
}

```


### Lang-Par table
```{r}
params_table <- data.frame()

for (n in 1:length(degree_distrib_ls)) {
    x <- unlist(degree_distrib_ls[[n]])
    new_pars <- get_mle_params(x)
    params_table <- rbind(params_table,new_pars[[1]])
}

params_table$lang <- source$language
colnames(params_table) <- c("lambda","q","gamma_1","gamma_2","kmax","lang")

params_table
print(xtable(params_table))
```


# Model Selection

## Compute AICs

```{r}
get_AIC <- function(m2logL,K,N) {
   m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}


aic_table <- data.frame()

for (n in 1:length(degree_distrib_ls)) {
    x <- unlist(degree_distrib_ls[[n]])
    new_pars <- get_mle_params(x)
    
    N <- length(x)
    M <- sum(x)
    M_1 <- sum(log(x))
    minus_log_likelihood_zeta2 <- 2*M_1 + N * log((pi^2)/6)
    
    aic_poiss <- get_AIC(new_pars[[2]][1],1,N)
    aic_geom <- get_AIC(new_pars[[2]][2],1,N)
    aic_zeta <- get_AIC(new_pars[[2]][3],1,N)
    aic_trunc_zeta <- get_AIC(new_pars[[2]][4],2,N)
    aic_zeta_2 <- get_AIC(2*minus_log_likelihood_zeta2,0,N)
    
    aic_ls <- c(aic_poiss,aic_geom,aic_zeta,aic_trunc_zeta,aic_zeta_2)
    aic_table <- rbind(aic_table,aic_ls)
    aic_table$best[n] <- which.min(aic_table[n,1:5])
}

aic_table$lang <- source$language
colnames(aic_table) <- c("Poisson","Geometric","Zeta","Trunc_Zeta","Zeta_2","best","lang")
aic_table
print(xtable(aic_table))

```

# Alternative distribution: Altman's function

```{r}
get_mle_pars_altman <- function(x) {
      M <- sum(x)
      M_1 <- sum(log(x))
          
      # Loglikelihood
      S <- function(gamma,delta) {
            s <- 0
            for (i in 1:N) {
              s <- s + (i^(-gamma)*exp(-delta*i))
              }
            return(s) 
      }
      
      minus_log_like_alt <- function(gamma,delta) {
            gamma*M_1 + delta*M + log(S(gamma,delta))
      }
      
      mle_alt <- mle(minus_log_like_alt, start = list(gamma = -2, delta = 4),method = "L-BFGS-B",
                     upper = list(gamma = -0.01))
      
      return(list(attributes(summary(mle_alt))$coef[1],
                  attributes(summary(mle_alt))$coef[2],
                  attributes(summary(mle_alt))$m2logL))
}

x <- unlist(degree_distrib_ls[[1]])
alt_pars <- get_mle_pars_altman(x)
get_AIC(alt_pars[[3]][1],2,N)
```


```{r}
aic_table <- data.frame()

for (n in 1:length(degree_distrib_ls)) {
    x <- unlist(degree_distrib_ls[[n]])
    new_pars <- get_mle_params(x)
    alt_pars <- get_mle_pars_altman(x)
    
    N <- length(x)
    M <- sum(x)
    M_1 <- sum(log(x))
    minus_log_likelihood_zeta2 <- 2*M_1 + N * log((pi^2)/6)
    
    aic_poiss <- get_AIC(new_pars[[2]][1],1,N)
    aic_geom <- get_AIC(new_pars[[2]][2],1,N)
    aic_zeta <- get_AIC(new_pars[[2]][3],1,N)
    aic_trunc_zeta <- get_AIC(new_pars[[2]][4],2,N)
    aic_zeta_2 <- get_AIC(2*minus_log_likelihood_zeta2,0,N)
    aic_alt <- get_AIC(alt_pars[[3]][1],2,N)
    
    aic_ls <- c(aic_poiss,aic_geom,aic_zeta,aic_trunc_zeta,aic_zeta_2,aic_alt)
    aic_table <- rbind(aic_table,aic_ls)
    aic_table$best[n] <- which.min(aic_table[n,1:6])
}

aic_table$lang <- source$language
colnames(aic_table) <- c("Poisson","Geometric","Zeta","Trunc_Zeta","Zeta_2","Altman","best","lang")
aic_table
```

```{r}
spectrum <- table(degree_distrib_ls[[1]])
barplot(spectrum, main = "English",
        xlab = "degree", ylab = "number of vertices", log = "xy")
```









### compare with real distributions
```{r}
degree_sequence = read.table("./samples_from_discrete_distributions/data/sample_of_geometric_with_parameter_0.2.txt",
                             header = FALSE)
```









