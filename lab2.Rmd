---
title: "CSN_lab2"
output: html_notebook
---

# Analysis of nodes degree distribution 

After finding the parameters and the best model, plot the data and a theoretical curve to see if there is sufficient agreement 

("I give x and y, use a double log scale for viz")

```{r}
#install.packages("stats4,VGAN")

library(ggplot2)
require("stats4") # for MLE
require("VGAM")

```


Degree sequence of the English network

```{r}
#degree_sequence = read.table("./data/English_degree_sequence.txt",
                  header = FALSE)
nrow(degree_sequence)   # number of nodes 
```
```{r}
sum(degree_sequence)    # sum of total degrees
sum(degree_sequence)/dim(degree_sequence)[1]    # mean degree
spectrum <- table(degree_sequence)
```


```{r}
barplot(spectrum, main = "English",
        xlab = "degree", ylab = "number of vertices")
```

```{r}
barplot(spectrum, main = "English",
        xlab = "degree", ylab = "number of vertices", log = "xy")
```



```{r}
source("summary_table.R")

```

```{r}
write_summary <- function(language,file) {
   degree_sequence = read.table(file, header = FALSE)
    return(c(language,length(degree_sequence$V1),max(degree_sequence$V1),sum(degree_sequence$V1)/length(degree_sequence$V1),length(degree_sequence$V1)/sum(degree_sequence$V1)))
}
```



# IN-DEGREE DISTRIBUTION

Table 1: Summary of the properties of the degree sequences. N is the number of nodes, M/N is mean degree where M is the sum of degrees.

```{r}
write_summary(source$language[1], source$file[1])
```


```{r}
source = read.table("list_in.txt", header = TRUE, 
         as.is = c("language","file"))

lang_tab = data.frame()
for (x in 1:nrow(source)) {
    out <- print(write_summary(source$language[x], source$file[x]))
    lang_tab = rbind(df, out)
}

```

```{r}
x <- 1:2
y <- 1:10
n <- max(length(x), length(y))
length(x) <- n                      
length(y) <- n

#lang_tab = data.frame()
#for (x in 1:nrow(source)) {
#    degree_sequence = read.table(source$file[x])
#    lang_tab = cbind(lang_tab, degree_sequence)
#}

en_degree_sequence = read.table("./data/English_in-degree_sequence.txt", header = FALSE)
bsq_degree_sequence = read.table("./data/Basque_in-degree_sequence.txt", header = FALSE)
degree_sequence = read.table("./data/English_in-degree_sequence.txt", header = FALSE)
degree_sequence = read.table("./data/English_in-degree_sequence.txt", header = FALSE)
degree_sequence = read.table("./data/English_in-degree_sequence.txt", header = FALSE)

```


## Fitting Distributions

```{r}
x <- bsq_degree_sequence$V1
M <- sum(x)
N <- length(x)
M_1 <- sum(log(x))
H <- function(kmax,gamma) {
    s <- 0
    for (i in 1:kmax) {
        s <- s + (1/(x[i]^gamma))
    }
    return(s)
}

## Poisson
minus_log_like_poisson <- function(lambda) {
  C <- 0;
  for(i in 1:N)
    for(j in 2:x[i])
      C<-C+log(j)
  return(- M * log(lambda) + N*(lambda + log(1-(exp(-lambda)))) + C)
}

mle_poisson <- mle(minus_log_like_poisson,
            start = list(lambda = M/N),
            method = "L-BFGS-B",
            lower = c(0.0000001))

attributes(summary(mle_poisson))$coef[1]


## Geometric
minus_log_like_geom <- function(q) {
     - (M-N)*log(1-q) - N*log(q)
}

mle_geom <- mle(minus_log_like_geom,
            start = list(q = N/M),
            method = "L-BFGS-B",
            lower = c(0.00001),
            upper = c(0.99999))

attributes(summary(mle_geom))$coef[1]



## zeta
minus_log_like_zeta <- function(gamma) {
     N * log(zeta(gamma)) + gamma * M_1
}

mle_zeta <- mle(minus_log_like_zeta,
            start = list(gamma = 2),
            method = "L-BFGS-B",
            lower = c(1.0000001))

attributes(summary(mle_zeta))$coef[1]



## Zeta with 2
minus_log_likelihood_zeta2 <- -2*M_1 + N * log((pi^2)/6)
minus_log_likelihood_zeta2



## Trunc Zeta
minus_log_like_trunc_zeta <- function(gamma) {
     gamma*M_1 + N*log(H(max(x),gamma))
}

mle_trunc_zeta <- mle(minus_log_like_trunc_zeta,
            start = list(gamma = 2),
            method = "L-BFGS-B",
            lower = c(1.0000001))

attributes(summary(mle_trunc_zeta))$coef[1]

```


# Model Selection

```{r}
m2logL <- attributes(summary(mle_zeta))$m2logL

get_AIC <- function(m2logL,K,N) {
   m2logL + 2*K*N/(N-K-1) # AIC with a correction for sample size
}

```



### compare with real distributions
```{r}
degree_sequence = read.table("./samples_from_discrete_distributions/data/sample_of_geometric_with_parameter_0.2.txt",
                             header = FALSE)
```









